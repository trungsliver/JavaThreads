<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/concurrentCollection/COWADemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/concurrentCollection/COWADemo.java" />
              <option name="originalContent" value="package concurrentCollection;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Random;&#10;import java.util.concurrent.CopyOnWriteArrayList;&#10;&#10;public class COWADemo {&#10;    public static void main(String[] args) {&#10;        Simulation simulation = new Simulation();&#10;        simulation.simulate();&#10;    }&#10;}&#10;&#10;&#10;class Simulation {&#10;    private final List&lt;Integer&gt; list;&#10;&#10;    public Simulation() {&#10;        list = new CopyOnWriteArrayList&lt;&gt;();&#10;        list.addAll(Arrays.asList(0,0,0,0,0,0,0,0));&#10;    }&#10;&#10;    public void simulate() {&#10;        Thread one = new Thread(new WriteTask(list));&#10;        Thread two = new Thread(new WriteTask(list));&#10;        Thread three = new Thread(new WriteTask(list));&#10;        Thread four = new Thread(new ReadTask(list));&#10;&#10;        one.start();&#10;        two.start();&#10;        three.start();&#10;        four.start();&#10;    }&#10;}&#10;&#10;class ReadTask implements Runnable {&#10;    private final List&lt;Integer&gt; list;&#10;&#10;    public ReadTask(List&lt;Integer&gt; list) {&#10;        this.list = list;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            try {&#10;                Thread.sleep(1000);&#10;            } catch (InterruptedException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;            System.out.println(list);&#10;        }&#10;    }&#10;}&#10;&#10;class WriteTask implements Runnable {&#10;    private List&lt;Integer&gt; list;&#10;    private Random random;&#10;&#10;    public WriteTask(List&lt;Integer&gt; list) {&#10;        this.list = list;&#10;        this.random = new Random();&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            try {&#10;                Thread.sleep(1200);&#10;            } catch (InterruptedException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;            list.set(random.nextInt(list.size()), random.nextInt(10));&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package concurrentCollection; // Khai báo package chứa class này&#10;&#10;import java.util.Arrays; // Import lớp Arrays để thao tác với mảng&#10;import java.util.List; // Import interface List&#10;import java.util.Random; // Import lớp Random để sinh số ngẫu nhiên&#10;import java.util.concurrent.CopyOnWriteArrayList; // Import lớp CopyOnWriteArrayList cho collection thread-safe&#10;&#10;public class COWADemo {&#10;    public static void main(String[] args) {&#10;        // Tạo đối tượng Simulation và chạy mô phỏng&#10;        Simulation simulation = new Simulation();&#10;        simulation.simulate();&#10;    }&#10;}&#10;&#10;// Lớp mô phỏng hoạt động đọc/ghi trên danh sách thread-safe&#10;class Simulation {&#10;    private final List&lt;Integer&gt; list; // Danh sách số nguyên dùng CopyOnWriteArrayList&#10;&#10;    public Simulation() {&#10;        list = new CopyOnWriteArrayList&lt;&gt;(); // Khởi tạo danh sách thread-safe&#10;        list.addAll(Arrays.asList(0,0,0,0,0,0,0,0)); // Thêm 8 số 0 vào danh sách&#10;    }&#10;&#10;    public void simulate() {&#10;        // Tạo 3 luồng ghi và 1 luồng đọc&#10;        Thread one = new Thread(new WriteTask(list));&#10;        Thread two = new Thread(new WriteTask(list));&#10;        Thread three = new Thread(new WriteTask(list));&#10;        Thread four = new Thread(new ReadTask(list));&#10;&#10;        // Khởi động các luồng&#10;        one.start();&#10;        two.start();&#10;        three.start();&#10;        four.start();&#10;    }&#10;}&#10;&#10;// Nhiệm vụ đọc danh sách liên tục&#10;class ReadTask implements Runnable {&#10;    private final List&lt;Integer&gt; list;&#10;&#10;    public ReadTask(List&lt;Integer&gt; list) {&#10;        this.list = list;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            try {&#10;                Thread.sleep(1000); // Dừng 1 giây giữa mỗi lần đọc&#10;            } catch (InterruptedException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;            System.out.println(list); // In ra danh sách hiện tại&#10;        }&#10;    }&#10;}&#10;&#10;// Nhiệm vụ ghi ngẫu nhiên vào danh sách liên tục&#10;class WriteTask implements Runnable {&#10;    private List&lt;Integer&gt; list;&#10;    private Random random;&#10;&#10;    public WriteTask(List&lt;Integer&gt; list) {&#10;        this.list = list;&#10;        this.random = new Random(); // Khởi tạo đối tượng sinh số ngẫu nhiên&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            try {&#10;                Thread.sleep(1200); // Dừng 1.2 giây giữa mỗi lần ghi&#10;            } catch (InterruptedException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;            // Ghi giá trị ngẫu nhiên vào vị trí ngẫu nhiên trong danh sách&#10;            list.set(random.nextInt(list.size()), random.nextInt(10));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/locks/readWriteLock/ReadWriteExample.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/locks/readWriteLock/ReadWriteExample.java" />
              <option name="originalContent" value="package locks.readWriteLock;&#10;&#10;import java.util.concurrent.locks.Lock;&#10;import java.util.concurrent.locks.ReadWriteLock;&#10;import java.util.concurrent.locks.ReentrantReadWriteLock;&#10;&#10;public class ReadWriteExample {&#10;    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();&#10;    private final Lock readLock = rwLock.readLock();&#10;    private final Lock writeLock = rwLock.writeLock();&#10;&#10;    private int sharedData = 0;&#10;&#10;    public void readData(String threadName) {&#10;        readLock.lock();&#10;        try {&#10;            System.out.println(threadName + &quot; đang đọc dữ liệu: &quot; + sharedData);&#10;            Thread.sleep(100); // mô phỏng thời gian đọc&#10;        } catch (InterruptedException e) {&#10;            e.printStackTrace();&#10;        } finally {&#10;            readLock.unlock();&#10;        }&#10;    }&#10;&#10;    public void writeData(String threadName, int value) {&#10;        writeLock.lock();&#10;        try {&#10;            System.out.println(threadName + &quot; đang ghi dữ liệu: &quot; + value);&#10;            Thread.sleep(200); // mô phỏng thời gian ghi&#10;            sharedData = value;&#10;            System.out.println(threadName + &quot; đã ghi xong.&quot;);&#10;        } catch (InterruptedException e) {&#10;            e.printStackTrace();&#10;        } finally {&#10;            writeLock.unlock();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        ReadWriteExample example = new ReadWriteExample();&#10;&#10;        Runnable reader = () -&gt; {&#10;            for (int i = 0; i &lt; 3; i++) {&#10;                example.readData(Thread.currentThread().getName());&#10;            }&#10;        };&#10;&#10;        Runnable writer = () -&gt; {&#10;            for (int i = 0; i &lt; 2; i++) {&#10;                example.writeData(Thread.currentThread().getName(), i * 100);&#10;            }&#10;        };&#10;&#10;        Thread t1 = new Thread(reader, &quot;Độc giả 1&quot;);&#10;        Thread t2 = new Thread(reader, &quot;Độc giả 2&quot;);&#10;        Thread t3 = new Thread(writer, &quot;Người ghi&quot;);&#10;&#10;        t1.start();&#10;        t2.start();&#10;        t3.start();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package locks.readWriteLock; // Khai báo package chứa class này&#10;&#10;import java.util.concurrent.locks.Lock; // Import interface Lock để sử dụng khóa&#10;import java.util.concurrent.locks.ReadWriteLock; // Import interface ReadWriteLock cho khóa đọc/ghi&#10;import java.util.concurrent.locks.ReentrantReadWriteLock; // Import lớp ReentrantReadWriteLock cho phép nhiều luồng đọc, một luồng ghi&#10;&#10;public class ReadWriteExample {&#10;    // Khởi tạo đối tượng ReadWriteLock để quản lý truy cập đồng thời&#10;    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();&#10;    // Tạo khóa đọc từ ReadWriteLock&#10;    private final Lock readLock = rwLock.readLock();&#10;    // Tạo khóa ghi từ ReadWriteLock&#10;    private final Lock writeLock = rwLock.writeLock();&#10;&#10;    // Biến dùng chung giữa các luồng&#10;    private int sharedData = 0;&#10;&#10;    // Phương thức đọc dữ liệu với tên luồng truyền vào&#10;    public void readData(String threadName) {&#10;        readLock.lock(); // Khóa đọc, cho phép nhiều luồng đọc đồng thời&#10;        try {&#10;            System.out.println(threadName + &quot; đang đọc dữ liệu: &quot; + sharedData); // In ra dữ liệu đang đọc&#10;            Thread.sleep(100); // Mô phỏng thời gian đọc&#10;        } catch (InterruptedException e) {&#10;            e.printStackTrace(); // Xử lý ngoại lệ nếu bị gián đoạn&#10;        } finally {&#10;            readLock.unlock(); // Mở khóa đọc sau khi đọc xong&#10;        }&#10;    }&#10;&#10;    // Phương thức ghi dữ liệu với tên luồng và giá trị truyền vào&#10;    public void writeData(String threadName, int value) {&#10;        writeLock.lock(); // Khóa ghi, chỉ cho phép một luồng ghi tại một thời điểm&#10;        try {&#10;            System.out.println(threadName + &quot; đang ghi dữ liệu: &quot; + value); // In ra dữ liệu đang ghi&#10;            Thread.sleep(200); // Mô phỏng thời gian ghi&#10;            sharedData = value; // Ghi giá trị mới vào biến dùng chung&#10;            System.out.println(threadName + &quot; đã ghi xong.&quot;); // Thông báo ghi xong&#10;        } catch (InterruptedException e) {&#10;            e.printStackTrace(); // Xử lý ngoại lệ nếu bị gián đoạn&#10;        } finally {&#10;            writeLock.unlock(); // Mở khóa ghi sau khi ghi xong&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        ReadWriteExample example = new ReadWriteExample(); // Tạo đối tượng ví dụ&#10;&#10;        // Định nghĩa tác vụ đọc cho các luồng đọc&#10;        Runnable reader = () -&gt; {&#10;            for (int i = 0; i &lt; 3; i++) { // Mỗi luồng đọc 3 lần&#10;                example.readData(Thread.currentThread().getName());&#10;            }&#10;        };&#10;&#10;        // Định nghĩa tác vụ ghi cho luồng ghi&#10;        Runnable writer = () -&gt; {&#10;            for (int i = 0; i &lt; 2; i++) { // Luồng ghi 2 lần&#10;                example.writeData(Thread.currentThread().getName(), i * 100);&#10;            }&#10;        };&#10;&#10;        // Tạo các luồng đọc và ghi với tên riêng&#10;        Thread t1 = new Thread(reader, &quot;Độc giả 1&quot;);&#10;        Thread t2 = new Thread(reader, &quot;Độc giả 2&quot;);&#10;        Thread t3 = new Thread(writer, &quot;Người ghi&quot;);&#10;&#10;        t1.start(); // Khởi động luồng đọc 1&#10;        t2.start(); // Khởi động luồng đọc 2&#10;        t3.start(); // Khởi động luồng ghi&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>